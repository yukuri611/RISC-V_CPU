$date
	Mon Jan 12 17:14:34 2026
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module CPU_testbench $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$scope module CPU $end
$var wire 32 # alu_input1 [31:0] $end
$var wire 1 ! clk $end
$var wire 1 $ reg_write $end
$var wire 1 " reset $end
$var wire 32 % write_data [31:0] $end
$var wire 5 & rs1 [4:0] $end
$var wire 32 ' read_data1 [31:0] $end
$var wire 5 ( rd [4:0] $end
$var wire 32 ) pc_out [31:0] $end
$var wire 7 * opcode [6:0] $end
$var wire 32 + instruction [31:0] $end
$var wire 12 , imm [11:0] $end
$var wire 3 - funct3 [2:0] $end
$var wire 32 . alu_result [31:0] $end
$var wire 32 / alu_input2 [31:0] $end
$var wire 4 0 alu_control [3:0] $end
$scope module ALU $end
$var wire 1 ! clk $end
$var wire 32 1 operand1 [31:0] $end
$var wire 32 2 operand2 [31:0] $end
$var wire 4 3 alu_control [3:0] $end
$var reg 32 4 alu_result [31:0] $end
$upscope $end
$scope module ALUControl $end
$var wire 1 ! clk $end
$var wire 3 5 funct3 [2:0] $end
$var reg 4 6 alu_control [3:0] $end
$upscope $end
$scope module Decoder $end
$var wire 1 ! clk $end
$var wire 5 7 rs1 [4:0] $end
$var wire 5 8 rd [4:0] $end
$var wire 7 9 opcode [6:0] $end
$var wire 32 : instruction [31:0] $end
$var wire 12 ; imm [11:0] $end
$var wire 3 < funct3 [2:0] $end
$upscope $end
$scope module IMem $end
$var wire 1 ! clk $end
$var wire 32 = instruction [31:0] $end
$var wire 32 > addr [31:0] $end
$upscope $end
$scope module PC $end
$var wire 1 ! clk $end
$var wire 32 ? pc_in [31:0] $end
$var wire 1 " reset $end
$var reg 32 @ pc_out [31:0] $end
$upscope $end
$scope module RegisterFile $end
$var wire 1 ! clk $end
$var wire 5 A read_reg1 [4:0] $end
$var wire 1 $ reg_write $end
$var wire 32 B write_data [31:0] $end
$var wire 5 C write_reg [4:0] $end
$var wire 32 D read_data1 [31:0] $end
$var integer 32 E i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b100000 E
b0 D
b1 C
bx B
b0 A
b0 @
b100 ?
b0 >
b100000000000010010011 =
b0 <
b1 ;
b100000000000010010011 :
b10011 9
b1 8
b0 7
bx 6
b0 5
bx 4
bx 3
b1 2
b0 1
bx 0
b1 /
bx .
b0 -
b1 ,
b100000000000010010011 +
b10011 *
b0 )
b1 (
b0 '
b0 &
bx %
1$
b0 #
1"
0!
$end
#1
b1 %
b1 B
b1 .
b1 4
b10 0
b10 3
b10 6
1!
#2
0!
#3
1!
#4
0!
0"
#5
b10 %
b10 B
b10 .
b10 4
b1 #
b1 1
b1 '
b1 D
b1 &
b1 7
b1 A
b100001000000010010011 +
b100001000000010010011 :
b100001000000010010011 =
b1000 ?
b100 )
b100 >
b100 @
1!
#6
0!
#7
b11 %
b11 B
b11 .
b11 4
b10 #
b10 1
b10 '
b10 D
b1100 ?
b1000 )
b1000 >
b1000 @
1!
#8
0!
#9
b10 %
b10 B
b10 .
b10 4
b11111111111111111111111111111111 /
b11111111111111111111111111111111 2
b111111111111 ,
b111111111111 ;
b11 #
b11 1
b11 '
b11 D
b11111111111100001000000010010011 +
b11111111111100001000000010010011 :
b11111111111100001000000010010011 =
b10000 ?
b1100 )
b1100 >
b1100 @
1!
#10
0!
#11
bx %
bx B
bx .
bx 4
bx /
bx 2
bx ,
bx ;
bx &
bx 7
bx A
bx -
bx 5
bx <
bx (
bx 8
bx C
bx *
bx 9
bx #
bx 1
bx '
bx D
bx +
bx :
bx =
b10100 ?
b10000 )
b10000 >
b10000 @
1!
#12
0!
#13
b11000 ?
b10100 )
b10100 >
b10100 @
1!
#14
0!
