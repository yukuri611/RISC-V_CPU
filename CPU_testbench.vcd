$date
	Tue Jan 13 17:50:03 2026
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module CPU_testbench $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$scope module CPU $end
$var wire 1 ! clk $end
$var wire 1 # reg_write $end
$var wire 1 " reset $end
$var wire 5 $ rs2 [4:0] $end
$var wire 5 % rs1 [4:0] $end
$var wire 32 & reg_read_data2 [31:0] $end
$var wire 32 ' reg_read_data1 [31:0] $end
$var wire 5 ( rd [4:0] $end
$var wire 7 ) opcode [6:0] $end
$var wire 32 * mem_read_data [31:0] $end
$var wire 32 + instruction [31:0] $end
$var wire 12 , imm [11:0] $end
$var wire 7 - funct7 [6:0] $end
$var wire 3 . funct3 [2:0] $end
$var wire 32 / current_pc [31:0] $end
$var wire 32 0 alu_result [31:0] $end
$var wire 4 1 alu_control [3:0] $end
$var reg 1 2 MemtoReg $end
$var reg 32 3 alu_input1 [31:0] $end
$var reg 32 4 alu_input2 [31:0] $end
$var reg 1 5 branch_taken $end
$var reg 32 6 next_pc [31:0] $end
$var reg 32 7 pc_branch [31:0] $end
$var reg 32 8 pc_plus_4 [31:0] $end
$var reg 32 9 reg_write_data [31:0] $end
$scope module ALU $end
$var wire 1 ! clk $end
$var wire 32 : operand1 [31:0] $end
$var wire 32 ; operand2 [31:0] $end
$var wire 4 < alu_control [3:0] $end
$var reg 32 = alu_result [31:0] $end
$upscope $end
$scope module ALUControl $end
$var wire 1 ! clk $end
$var wire 7 > opcode [6:0] $end
$var wire 7 ? funct7 [6:0] $end
$var wire 3 @ funct3 [2:0] $end
$var reg 4 A alu_control [3:0] $end
$upscope $end
$scope module DMem $end
$var wire 32 B addr [31:0] $end
$var wire 1 ! clk $end
$var wire 1 C mem_read $end
$var wire 1 D mem_write $end
$var wire 32 E read_data [31:0] $end
$var wire 32 F write_data [31:0] $end
$scope begin $ivl_for_loop0 $end
$var integer 32 G i [31:0] $end
$upscope $end
$upscope $end
$scope module Decoder $end
$var wire 1 ! clk $end
$var wire 5 H rs2 [4:0] $end
$var wire 5 I rs1 [4:0] $end
$var wire 5 J rd [4:0] $end
$var wire 7 K opcode [6:0] $end
$var wire 32 L instruction [31:0] $end
$var wire 7 M funct7 [6:0] $end
$var wire 3 N funct3 [2:0] $end
$var reg 12 O imm [11:0] $end
$upscope $end
$scope module IMem $end
$var wire 1 ! clk $end
$var wire 32 P instruction [31:0] $end
$var wire 32 Q addr [31:0] $end
$upscope $end
$scope module PC $end
$var wire 1 ! clk $end
$var wire 32 R pc_in [31:0] $end
$var wire 1 " reset $end
$var reg 32 S pc_out [31:0] $end
$upscope $end
$scope module RegisterFile $end
$var wire 1 ! clk $end
$var wire 5 T read_reg1 [4:0] $end
$var wire 5 U read_reg2 [4:0] $end
$var wire 1 # reg_write $end
$var wire 32 V write_data [31:0] $end
$var wire 5 W write_reg [4:0] $end
$var wire 32 X read_data2 [31:0] $end
$var wire 32 Y read_data1 [31:0] $end
$var integer 32 Z i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b100000 Z
b0 Y
b0 X
b1 W
b1010 V
b1010 U
b0 T
b0 S
b100 R
b0 Q
b101000000000000010010011 P
b1010 O
b0 N
b0 M
b101000000000000010010011 L
b10011 K
b1 J
b0 I
b1010 H
b100000000 G
b0 F
b0 E
0D
0C
b1010 B
b10 A
b0 @
b0 ?
b10011 >
b1010 =
b10 <
b1010 ;
b0 :
b1010 9
b100 8
b10100 7
b100 6
05
b1010 4
b0 3
02
b10 1
b1010 0
b0 /
b0 .
b0 -
b1010 ,
b101000000000000010010011 +
b0 *
b10011 )
b1 (
b0 '
b0 &
b0 %
b1010 $
1#
1"
0!
$end
#1
1!
#2
0!
#3
1!
#4
0!
0"
#5
b10 (
b10 J
b10 W
b101000000000000100010011 +
b101000000000000100010011 L
b101000000000000100010011 P
b1000 6
b1000 R
b11000 7
b1000 8
b100 /
b100 Q
b100 S
1!
#6
0!
#7
b0 9
b0 V
b0 0
b0 =
b0 B
b0 4
b0 ;
b11 (
b11 J
b11 W
b0 $
b0 H
b0 U
b0 ,
b0 O
b110010011 +
b110010011 L
b110010011 P
b1100 6
b1100 R
b1000 7
b1100 8
b1000 /
b1000 Q
b1000 S
1!
#8
0!
#9
b1010 4
b1010 ;
b1010 3
b1010 :
b110 1
b110 <
b110 A
b1010 '
b1010 Y
b1010 &
b1010 F
b1010 X
15
b1100011 )
b1100011 >
b1100011 K
b1000 (
b1000 J
b1000 W
b1 %
b1 I
b1 T
b10 $
b10 H
b10 U
b100 ,
b100 O
b1000001000010001100011 +
b1000001000010001100011 L
b1000001000010001100011 P
b10100 6
b10100 R
b10100 7
b10000 8
b1100 /
b1100 Q
b1100 S
1!
#10
0!
#11
b1 9
b1 V
b1 0
b1 =
b1 B
b0 3
b0 :
b10 1
b10 <
b10 A
b0 '
b0 Y
b1 4
b1 ;
05
b10011 )
b10011 >
b10011 K
b11 (
b11 J
b11 W
b0 %
b0 I
b0 T
b1 $
b1 H
b1 U
b1 ,
b1 O
b100000000000110010011 +
b100000000000110010011 L
b100000000000110010011 P
b11000 6
b11000 R
b10110 7
b11000 8
b10100 /
b10100 Q
b10100 S
1!
#12
0!
#13
b10 9
b10 V
b10 0
b10 =
b10 B
b10 4
b10 ;
b100 (
b100 J
b100 W
b10 $
b10 H
b10 U
b10 ,
b10 O
b1000000000001000010011 +
b1000000000001000010011 L
b1000000000001000010011 P
b11100 6
b11100 R
b11100 7
b11100 8
b11000 /
b11000 Q
b11000 S
1!
#14
0!
#15
b0 9
b0 V
15
b0 0
b0 =
b0 B
b110 1
b110 <
b110 A
b0 &
b0 F
b0 X
b0 4
b0 ;
b1100011 )
b1100011 >
b1100011 K
b0 (
b0 J
b0 W
b0 $
b0 H
b0 U
b0 ,
b0 O
b1100011 +
b1100011 L
b1100011 P
b11100 6
b11100 R
b11100 7
b100000 8
b11100 /
b11100 Q
b11100 S
1!
#16
0!
#17
1!
#18
0!
#19
1!
#20
0!
#21
1!
#22
0!
#23
1!
#24
0!
