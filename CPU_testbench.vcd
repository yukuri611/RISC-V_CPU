$date
	Mon Jan 12 20:51:38 2026
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module CPU_testbench $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$scope module CPU $end
$var wire 32 # alu_input1 [31:0] $end
$var wire 1 ! clk $end
$var wire 1 $ reg_write $end
$var wire 1 " reset $end
$var wire 32 % write_data [31:0] $end
$var wire 5 & rs1 [4:0] $end
$var wire 32 ' read_data1 [31:0] $end
$var wire 5 ( rd [4:0] $end
$var wire 32 ) pc_out [31:0] $end
$var wire 7 * opcode [6:0] $end
$var wire 32 + instruction [31:0] $end
$var wire 12 , imm [11:0] $end
$var wire 3 - funct3 [2:0] $end
$var wire 32 . alu_result [31:0] $end
$var wire 32 / alu_input2 [31:0] $end
$var wire 4 0 alu_control [3:0] $end
$scope module ALU $end
$var wire 1 ! clk $end
$var wire 32 1 operand1 [31:0] $end
$var wire 32 2 operand2 [31:0] $end
$var wire 4 3 alu_control [3:0] $end
$var reg 32 4 alu_result [31:0] $end
$upscope $end
$scope module ALUControl $end
$var wire 1 ! clk $end
$var wire 3 5 funct3 [2:0] $end
$var reg 4 6 alu_control [3:0] $end
$upscope $end
$scope module Decoder $end
$var wire 1 ! clk $end
$var wire 5 7 rs1 [4:0] $end
$var wire 5 8 rd [4:0] $end
$var wire 7 9 opcode [6:0] $end
$var wire 32 : instruction [31:0] $end
$var wire 12 ; imm [11:0] $end
$var wire 3 < funct3 [2:0] $end
$upscope $end
$scope module IMem $end
$var wire 1 ! clk $end
$var wire 32 = instruction [31:0] $end
$var wire 32 > addr [31:0] $end
$upscope $end
$scope module PC $end
$var wire 1 ! clk $end
$var wire 32 ? pc_in [31:0] $end
$var wire 1 " reset $end
$var reg 32 @ pc_out [31:0] $end
$upscope $end
$scope module RegisterFile $end
$var wire 1 ! clk $end
$var wire 5 A read_reg1 [4:0] $end
$var wire 1 $ reg_write $end
$var wire 32 B write_data [31:0] $end
$var wire 5 C write_reg [4:0] $end
$var wire 32 D read_data1 [31:0] $end
$var integer 32 E i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b100000 E
b0 D
b1 C
b101 B
b0 A
b0 @
b100 ?
b0 >
b10100000000000010010011 =
b0 <
b101 ;
b10100000000000010010011 :
b10011 9
b1 8
b0 7
b10 6
b0 5
b101 4
b10 3
b101 2
b0 1
b10 0
b101 /
b101 .
b0 -
b101 ,
b10100000000000010010011 +
b10011 *
b0 )
b1 (
b0 '
b0 &
b101 %
1$
b0 #
1"
0!
$end
#1
1!
#2
0!
#3
1!
#4
0!
0"
#5
b111 %
b111 B
b111 .
b111 4
b101 #
b101 1
b101 '
b101 D
b1 0
b1 3
b1 6
b11 /
b11 2
b11 ,
b11 ;
b1 &
b1 7
b1 A
b110 -
b110 5
b110 <
b10 (
b10 8
b10 C
b1100001110000100010011 +
b1100001110000100010011 :
b1100001110000100010011 =
b1000 ?
b100 )
b100 >
b100 @
1!
#6
0!
#7
b1 %
b1 B
b1 .
b1 4
b0 0
b0 3
b0 6
b111 -
b111 5
b111 <
b11 (
b11 8
b11 C
b1100001111000110010011 +
b1100001111000110010011 :
b1100001111000110010011 =
b1100 ?
b1000 )
b1000 >
b1000 @
1!
#8
0!
#9
bx %
bx B
bx .
bx 4
bx #
bx 1
bx '
bx D
bx /
bx 2
bx ,
bx ;
bx &
bx 7
bx A
bx -
bx 5
bx <
bx (
bx 8
bx C
bx *
bx 9
bx +
bx :
bx =
b10000 ?
b1100 )
b1100 >
b1100 @
1!
#10
0!
#11
b10100 ?
b10000 )
b10000 >
b10000 @
1!
#12
0!
#13
b11000 ?
b10100 )
b10100 >
b10100 @
1!
#14
0!
