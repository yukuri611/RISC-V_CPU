$date
	Tue Jan 13 16:03:22 2026
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module CPU_testbench $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$scope module CPU $end
$var wire 1 ! clk $end
$var wire 1 # reg_write $end
$var wire 1 " reset $end
$var wire 5 $ rs2 [4:0] $end
$var wire 5 % rs1 [4:0] $end
$var wire 32 & reg_read_data2 [31:0] $end
$var wire 32 ' reg_read_data1 [31:0] $end
$var wire 5 ( rd [4:0] $end
$var wire 32 ) pc_out [31:0] $end
$var wire 7 * opcode [6:0] $end
$var wire 32 + mem_read_data [31:0] $end
$var wire 32 , instruction [31:0] $end
$var wire 12 - imm [11:0] $end
$var wire 7 . funct7 [6:0] $end
$var wire 3 / funct3 [2:0] $end
$var wire 32 0 alu_result [31:0] $end
$var wire 4 1 alu_control [3:0] $end
$var reg 1 2 MemtoReg $end
$var reg 32 3 alu_input1 [31:0] $end
$var reg 32 4 alu_input2 [31:0] $end
$var reg 32 5 reg_write_data [31:0] $end
$scope module ALU $end
$var wire 1 ! clk $end
$var wire 32 6 operand1 [31:0] $end
$var wire 32 7 operand2 [31:0] $end
$var wire 4 8 alu_control [3:0] $end
$var reg 32 9 alu_result [31:0] $end
$upscope $end
$scope module ALUControl $end
$var wire 1 ! clk $end
$var wire 7 : opcode [6:0] $end
$var wire 7 ; funct7 [6:0] $end
$var wire 3 < funct3 [2:0] $end
$var reg 4 = alu_control [3:0] $end
$upscope $end
$scope module DMem $end
$var wire 32 > addr [31:0] $end
$var wire 1 ! clk $end
$var wire 1 ? mem_read $end
$var wire 1 @ mem_write $end
$var wire 32 A read_data [31:0] $end
$var wire 32 B write_data [31:0] $end
$scope begin $ivl_for_loop0 $end
$var integer 32 C i [31:0] $end
$upscope $end
$upscope $end
$scope module Decoder $end
$var wire 1 ! clk $end
$var wire 5 D rs2 [4:0] $end
$var wire 5 E rs1 [4:0] $end
$var wire 5 F rd [4:0] $end
$var wire 7 G opcode [6:0] $end
$var wire 32 H instruction [31:0] $end
$var wire 7 I funct7 [6:0] $end
$var wire 3 J funct3 [2:0] $end
$var reg 12 K imm [11:0] $end
$upscope $end
$scope module IMem $end
$var wire 1 ! clk $end
$var wire 32 L instruction [31:0] $end
$var wire 32 M addr [31:0] $end
$upscope $end
$scope module PC $end
$var wire 1 ! clk $end
$var wire 32 N pc_in [31:0] $end
$var wire 1 " reset $end
$var reg 32 O pc_out [31:0] $end
$upscope $end
$scope module RegisterFile $end
$var wire 1 ! clk $end
$var wire 5 P read_reg1 [4:0] $end
$var wire 5 Q read_reg2 [4:0] $end
$var wire 1 # reg_write $end
$var wire 32 R write_data [31:0] $end
$var wire 5 S write_reg [4:0] $end
$var wire 32 T read_data2 [31:0] $end
$var wire 32 U read_data1 [31:0] $end
$var integer 32 V i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b100000 V
b0 U
b0 T
b1 S
b1010 R
b1010 Q
b0 P
b0 O
b100 N
b0 M
b101000000000000010010011 L
b1010 K
b0 J
b0 I
b101000000000000010010011 H
b10011 G
b1 F
b0 E
b1010 D
b100000000 C
b0 B
b0 A
0@
0?
b1010 >
b10 =
b0 <
b0 ;
b10011 :
b1010 9
b10 8
b1010 7
b0 6
b1010 5
b1010 4
b0 3
02
b10 1
b1010 0
b0 /
b0 .
b1010 -
b101000000000000010010011 ,
b0 +
b10011 *
b0 )
b1 (
b0 '
b0 &
b0 %
b1010 $
1#
1"
0!
$end
#1
1!
#2
0!
#3
1!
#4
0!
0"
#5
b10100 5
b10100 R
b10100 0
b10100 9
b10100 >
b10100 4
b10100 7
b10 (
b10 F
b10 S
b10100 $
b10100 D
b10100 Q
b10100 -
b10100 K
b1010000000000000100010011 ,
b1010000000000000100010011 H
b1010000000000000100010011 L
b1000 N
b100 )
b100 M
b100 O
1!
#6
0!
#7
b11110 5
b11110 R
b11110 0
b11110 9
b11110 >
b1010 3
b1010 6
b1010 '
b1010 U
b10100 &
b10100 B
b10100 T
b10100 4
b10100 7
b110011 *
b110011 :
b110011 G
b11 (
b11 F
b11 S
b1 %
b1 E
b1 P
b10 $
b10 D
b10 Q
b10 -
b10 K
b1000001000000110110011 ,
b1000001000000110110011 H
b1000001000000110110011 L
b1100 N
b1000 )
b1000 M
b1000 O
1!
#8
0!
#9
b1010 5
b1010 R
b1010 0
b1010 9
b1010 >
b1010 4
b1010 7
b10100 3
b10100 6
b10100 '
b10100 U
b1010 &
b1010 B
b1010 T
b110 1
b110 8
b110 =
b100 (
b100 F
b100 S
b10 %
b10 E
b10 P
b1 $
b1 D
b1 Q
b100000 .
b100000 ;
b100000 I
b10000000001 -
b10000000001 K
b1000000000100010000001000110011 ,
b1000000000100010000001000110011 H
b1000000000100010000001000110011 L
b10000 N
b1100 )
b1100 M
b1100 O
1!
#10
0!
#11
b101 5
b101 R
b101 0
b101 9
b101 >
b0 3
b0 6
b0 '
b0 U
b0 &
b0 B
b0 T
b10 1
b10 8
b10 =
b101 4
b101 7
b10011 *
b10011 :
b10011 G
b1 (
b1 F
b1 S
b0 %
b0 E
b0 P
b101 $
b101 D
b101 Q
b0 .
b0 ;
b0 I
b101 -
b101 K
b10100000000000010010011 ,
b10100000000000010010011 H
b10100000000000010010011 L
b10100 N
b10000 )
b10000 M
b10000 O
1!
#12
0!
#13
b11 5
b11 R
b11 0
b11 9
b11 >
b11110 &
b11110 B
b11110 T
b11 4
b11 7
b10 (
b10 F
b10 S
b11 $
b11 D
b11 Q
b11 -
b11 K
b1100000000000100010011 ,
b1100000000000100010011 H
b1100000000000100010011 L
b11000 N
b10100 )
b10100 M
b10100 O
1!
#14
0!
#15
b1 5
b1 R
b1 0
b1 9
b1 >
b101 3
b101 6
b0 1
b0 8
b0 =
b101 '
b101 U
b11 &
b11 B
b11 T
b11 4
b11 7
b110011 *
b110011 :
b110011 G
b11 (
b11 F
b11 S
b111 /
b111 <
b111 J
b1 %
b1 E
b1 P
b10 $
b10 D
b10 Q
b10 -
b10 K
b1000001111000110110011 ,
b1000001111000110110011 H
b1000001111000110110011 L
b11100 N
b11000 )
b11000 M
b11000 O
1!
#16
0!
#17
b111 5
b111 R
b111 0
b111 9
b111 >
b1 1
b1 8
b1 =
b110 /
b110 <
b110 J
b1000001110000110110011 ,
b1000001110000110110011 H
b1000001110000110110011 L
b100000 N
b11100 )
b11100 M
b11100 O
1!
#18
0!
#19
bx 3
bx 6
bx '
bx U
bx &
bx B
bx T
b1111 1
b1111 8
b1111 =
b0 4
b0 7
x@
x?
bx *
bx :
bx G
bx (
bx F
bx S
bx /
bx <
bx J
bx %
bx E
bx P
bx $
bx D
bx Q
bx .
bx ;
bx I
bx -
bx K
bx ,
bx H
bx L
b100100 N
b100000 )
b100000 M
b100000 O
1!
#20
0!
#21
b101000 N
b100100 )
b100100 M
b100100 O
1!
#22
0!
#23
b101100 N
b101000 )
b101000 M
b101000 O
1!
#24
0!
